*** Begin Patch
*** Update File: src/data_streaming/realtime_trader.py
@@
     def start(self) -> bool:
-        with self._lock:
-            if self.is_trading:
-                self._safe_send_message("ðŸŸ¢ Trader already running.")
-                return True
-            self.is_trading = True
-        self._safe_send_alert("START")
-        logger.info("âœ… Trading started.")
-        return True
+        with self._lock:
+            if self.is_trading:
+                self._safe_send_message("ðŸŸ¢ Trader already running.")
+                return True
+            self.is_trading = True
+        self._safe_send_alert("START")
+        logger.info("âœ… Trading started.")
+        # Kick the first cycle immediately so strikes show without waiting 30s
+        try:
+            import threading
+            threading.Thread(target=self._smart_fetch_and_process, daemon=True).start()
+        except Exception:
+            self._smart_fetch_and_process()
+        return True
@@
-    def _is_trading_hours(self, current_time: datetime) -> bool:
-        # old implementation
-        start = 9 * 60 + 15
-        end = 15 * 60 + 30
-        cur = current_time.hour * 60 + current_time.minute
-        return start <= cur <= end
+    def _is_trading_hours(self, current_time: datetime) -> bool:
+        """IST market hours with .env override and weekday guard (Monâ€“Fri)."""
+        if getattr(Config, "ALLOW_OFFHOURS_TESTING", False):
+            return True
+        start_str = getattr(Config, "TIME_FILTER_START", "09:15")
+        end_str   = getattr(Config, "TIME_FILTER_END",   "15:30")
+        try:
+            sh, sm = [int(x) for x in start_str.split(":")]
+            eh, em = [int(x) for x in end_str.split(":")]
+        except Exception:
+            sh, sm, eh, em = 9, 15, 15, 30
+        if current_time.weekday() > 4:
+            return False
+        cur = current_time.hour * 60 + current_time.minute
+        return (sh * 60 + sm) <= cur <= (eh * 60 + em)
@@
     def _smart_fetch_and_process(self) -> None:
-        try:
+        try:
+            logger.debug("tick: smart_fetch (trading=%s live=%s)", self.is_trading, self.live_mode)
             now = datetime.now()
             if not self._is_trading_hours(now) and not getattr(
                 Config, "ALLOW_OFFHOURS_TESTING", False
             ):
                 return
             if not self.is_trading:
                 return
             if self._is_circuit_breaker_tripped():
                 return
             self.fetch_and_process_data()
         except Exception as e:
             logger.error(f"Error in smart fetch and process: {e}")
@@
     def fetch_and_process_data(self) -> None:
         t0 = time.time()
         try:
             kite = getattr(self.order_executor, "kite", None)
             if not kite:
                 logger.error("KiteConnect instance not found. Is live mode enabled?")
                 return
@@
-            # 1) Refresh instruments if needed
-            self._refresh_instruments_cache()
+            # 1) Refresh instruments if needed
+            self._refresh_instruments_cache()
+            cached_nfo, cached_nse = self._get_cached_instruments()
+            if not cached_nfo and not cached_nse:
+                logger.warning("Instrument cache empty; forcing refresh onceâ€¦")
+                self._refresh_instruments_cache(force=True)
+                cached_nfo, cached_nse = self._get_cached_instruments()
+                if not cached_nfo and not cached_nse:
+                    logger.error("Instrument cache is empty after forced refresh. Cannot proceed.")
+                    return
-            cached_nfo, cached_nse = self._get_cached_instruments()
*** End Patch